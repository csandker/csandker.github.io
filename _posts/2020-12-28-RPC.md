---
layout:	post
title:	"An offensive review of RPC"
date:	2020-12-27 10:00:00 +0200
abstract: "TODO..."
tags: IPC
---

## Contents:
{: .no_toc .toc-header}
* TOC
{:toc}

## Introduction

**R**emote **P**rocedure **C**alls (RPC) is a technology to enable data communication between a client and a server across process and machine boundaries (network communication). Therefore RPC is a Inter Process Communication (<b>IPC</b>) technology. Other technologies in this category are for example LPC, ALPC or Named Pipes.<br>
As the name and this category implies RPC is used to make calls to remote Servers to exchange/deliver data or to trigger a remote routine being started. The terminology "remote" in this case does not describe a requirement, but is more meant to express where RPC communications is most useful. An RPC server does not have to be on a remote machine, and in theory does not even has to be in a different process (although this would make sense). In theory you could implement a RPC server & client in DLLs, load them into the same process and exchange messages, but you wouldn't gain much as the messages would still be routed through other components outside of your process (such as the kernel, but more on this later) and you would try to make use of an "Inter" Process Communication technology for "Intra" Process Communication.<br>
Moreover an RPC server does not need to be on a remote machine, but could as well be called from a local client.

Within this blog post you can join me in discovering the insides of RPC, how it works & operates and how to implement and attack RPC clients and servers.<br>
This post is is made from an offensive view point and tries to cover the most relevant aspects the attack surface of RPC from an attackers perspective. A more defensive geared view on RPC can for example be found at [https://ipc-research.readthedocs.io/en/latest/subpages/RPC.html](https://ipc-research.readthedocs.io/en/latest/subpages/RPC.html) by [Jonathan Johnson](https://twitter.com/jsecurity101)

The below post will contain some references to code from my sample implementations, all of this code can be found here: [https://githuber.com/csandker/TODO](https://githuber.com/csandker/TODO)

## History

Microsoft's RPC implementation is based on the RPC implementation of the Distributed Computing Environment (DCE) standard developed by the Open Software Foundation (OSF).

“One of the key companies that contributed was Apollo Computer, who brought in NCA – “Network Computing Architecture” which became Network Computing System (NCS) and then a major part of DCE/RPC itself”
Source: https://kganugapati.wordpress.com/tag/msrpc/

Microsoft hired Paul Leach, one of the founds of Apollo, which might be how RPC came into Windows.

Microsot adjusted the DCE model to fit their programming scheme and based the communication of RPC on Named Pipes.
“The protocol conventions in DCE/RPC were ncacn_ip_tcp and ncadg_ip_udp, but Microsoft added  ncacn_np  protocol – connection oriented semantics over SMB named pipes” - Source: https://kganugapati.wordpress.com/tag/msrpc/

## RPC Messaging

RPC is a client-server technology with messaging architecture similar to COM (Component Object Model), which on a high level consists of the following three components:

- A server & client process that are responsible for registering an RPC interface an associated binding information (more on this later on)
- Server & client Stubs that are responsible for marshalling incoming and outgoing data
- The server's & client's RPC runtime library (rpcrt4.dll) takes the stub data and sends them over the wire using the specified protocol (examples and details will follow)

A visual overview of this message architecture can be found at [https://docs.microsoft.com/en-us/windows/win32/rpc/how-rpc-works](https://docs.microsoft.com/en-us/windows/win32/rpc/how-rpc-works) as shown below:

![RPC Message Flow](/public/img/2020-12-27-RPC/RPCMessageFlow.png)

Later on, in section [RPC Communication Flow](#rpc-communication-flow), i will provide an overview of the steps involved from creating an RPC server to sending a message, but before we can dive into that we need to clarify a few RPC terminology bits.

### RPC Protocol Sequence

The <b>RPC Protocol Sequence</b> is a constant string that defines which protocol the RPC runtime should use to transfer messages.<br>
This string defines which RPC protocol, transport and network protocol should be used.<br>
Microsoft supports the following three RPC protocols:
- Network Computing Architecture connection-oriented protocol (NCACN)
- Network Computing Architecture datagram protocol (NCADG)
- Network Computing Architecture local remote procedure call (NCALRPC)

In most scenarios where a connection is made across system boundaries you will find NCACN, whereas NCALRPC is recommended for local RPC communication.<br>
The most relevant transport protocols you'll find are named pipes (np), whereas the classic network protocols can be TCP/IP, UDP or HTTP.

The protocol sequence is a defined constant string assembled from the above parts, e.g. ncacn_nb_tcp for a connection-oriented communication based on named pipes over TCP.<br>
The full list of RPC protocol sequence constants can be found at: [https://docs.microsoft.com/en-us/windows/win32/rpc/protocol-sequence-constants](https://docs.microsoft.com/en-us/windows/win32/rpc/protocol-sequence-constants).

### RPC Interfaces

In order to establish a communication channel the RPC runtime needs to know what methods (aka. "functions") and parameters your server offers and what data your client is sending. These information are defined in a so called "Interface". Side note: If you're familiar with interfaces in COM, this is the same thing.<br>
To get an idea of how an interface could be defined, let's take this example from my [Sample Code](TODO):

**Interface1.idl**
```c++
[
	// UUID: A unique identifier that distinguishes this
	// interface from other interfaces.
	uuid(9510b60a-2eac-43fc-8077-aaefbdf3752b),

	// This is version 1.0 of this interface.
	version(1.0),

	
	// Using an implicit handle here named hExample1Binding:
	implicit_handle(handle_t hImplicitBinding)
	
]
interface Example1 // The interface is named Example1
{
	// A function that takes a zero-terminated string.
	int Output(
		[in, string] const char* pszOutput);
	//[out, string] const char* szReturn);

	void Shutdown();
}
```

The first thing to note is that interfaces are defined in an Interface Definition Language (IDL) file. The definitions in this will later on be compiled by the Microsoft IDL compiler (midl.exe) into header and source code files that can be used by the server and client.<br>
The interface header is rather self explanatory with the given comments - ignore the *implicit_handle* instruction for now, we get into implicit and explicit handles shortly.<br>
The body of the interface describes the methods that this interfaces exposes, their return values and their parameters. The ```[in, string]``` statement within parameter definition of the *Output* function is not mandatory but aids the understanding of what this parameter is used for.<br>
Side note: You could specify various interface attributes in an Application Configuration File (ACF), some such as the type of binding (explicit vs. implicit) can be placed in the IDL file, but for more complex interfaces you might want to add an extra ACF file per interface.

### RPC Binding

Once your client connects to an RPC server you create what Microsoft calls a "Binding". Or to put it with [Microsoft's words](https://docs.microsoft.com/en-us/windows/win32/rpc/binding-handles):
<pre>
Binding is the process of creating a logical connection between a client program and a server program. The information that composes the binding between client and server is represented by a structure called a binding handle.
</pre>
The terminology of **binding handles** gets clearer once we put some context on it. Technically there three types of binding handles:
- Implicit
- Explicit
- Automatic

Side note: You could implement custom binding handles as described in [here](https://docs.microsoft.com/en-us/windows/win32/rpc/primitive-and-custom-binding-handles), but we ignore this for this post, as this is rather uncommon and you're good with the default types.

**Implicit binding handles** allow your client to connect to and communicate with a specific RPC server (specified by the UUID in the IDL file). The downside is implicit bindings are not thread safe, multi-threaded applications should therefore use explicit bindings. Implicit binding handles are defined in the IDL file as shown in the sample IDL code above or in the [Sample Implicit Interface](TODO)<br>
**Explicit binding handles** allow your client to connect to and communicate with multiple RPC servers. Explicit binding handles are recommended to use due to being thread safe and allow for multiple connections. An example of an explicit binding handle definition can be found in my code [here](TODO).<br>
**Automatic binding** is a solution in between for the lazy developer, who doesn't want to fiddle around with binding handles and let the RPC runtime figure out what is needed. My recommendation would be to use explicit handles just to be aware of what you doing.

Why do i need binding handles in the first place you might ask at this point. Binding handles allow you to secure the connection between your client and server and therefore form what Microsoft terms **"authenticated" bindings**.

### Anonymous & Authenticated Bindings

Let's say you've got a plain and simple RPC server running, now a client connects to your server. If you didn't specify anything expect the bare minimum (which i will list shortly), this connection between client and server is referred to as **anonymous** or **unauthenticated** binding, due to the fact that your server got no clue who connected to it.<br>
To avoid any client from connecting and to level up the security of your server there are three gears you can turn:
- You can set registration flags when registering your server interface
- You can set a Security callback with a custom routine to check whether a requesting client should be allowed or denied
- You can set authentication information associated with your binding handle to specify a security service provider and an SPN to represent your RPC server.

Let's look at those three gears step-by-step.<br>
First of all when you create your server you need to register your interface, for example with a call to [RpcServerRegisterIf2](https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcserverregisterif2) - I'll show you where this call comes into play in section [Client & Server Implementation](#client--server-implementation). As a fourth parameter to *RpcServerRegisterIf2* you can specify [Interface Registration Flags](https://docs.microsoft.com/en-us/windows/win32/rpc/interface-registration-flags), such as RPC_IF_ALLOW_LOCAL_ONLY to only allow local connections.<br>
A sample call could look like this:

```c++
RPC_STATUS rpcStatus = RpcServerRegisterIf2(
    Example1_v1_0_s_ifspec,         // Interface to register.
    NULL,                           // Use the MIDL generated entry-point vector.
    NULL,                           // Use the MIDL generated entry-point vector.
    RPC_IF_ALLOW_LOCAL_ONLY,        // Only allow local connections
    RPC_C_LISTEN_MAX_CALLS_DEFAULT, // Use default number of concurrent calls.
    (unsigned)-1,                   // Infinite max size of incoming data blocks.
    NULL);                          // No security callback.
```

Next on the list is the security callback, which you could set as the last parameter of the above call. An always-allow callback could look like this:

```c++
// Naive security callback.
RPC_STATUS CALLBACK SecurityCallback(RPC_IF_HANDLE hInterface, void* pBindingHandle)
{
	return RPC_S_OK; // Always allow anyone.
}
```

To include this Security callback simply set the last parameter of the *RpcServerRegisterIf2* function to the name of your security callback function, in which this case is "SecurityCallback".<br>
This callback function can be implemented in any way you like, you could for example allow/deny connections based on IPs.

Last but not least we have the authentication information, for which we step into the next section, which is the last bit of RPC terminology we need to introduce... i promise.

### Authenticated Bindings

Okay so far you should know that you can create an implicit and explicit interface and use a few Windows API calls to setup your RPC server. In the previous section i've added that once you register your server you can set registration flags and a callback to secure you server and filter who can access your server. The last piece in the puzzle is now an extra Windows API that allows the server and client to respectively to authenticate your binding. But why would you?<br>
**Authenticated Bindings in combination with the right registration flag (RPC_IF_ALLOW_SECURE_ONLY) enables your RPC Server to ensure that only authenticated users can connect and in case the client allows it enables the server to figure out who connected to it by impersonating the client**.<br>
You could as well use the SecurityCallback to deny any anonymous client from connecting, but you would need to implement the filter mechanism on your own based on attributes you control. You wouldn't be able to determine if the client is for example a valid domain user, because you don't have any access account information.

Okay so how do you specify an authenticated binding?

**Authenticating the binding on the Server side:** [Example code [here](TODO)]
```c++
RPC_STATUS rpcStatus = RpcServerRegisterAuthInfo(
    pszSpn,             // Server principal name
    RPC_C_AUTHN_WINNT,	// using NTLM as authentication service provider
    NULL,               // Use default key function, which  is ignored for NTLM SSP
    NULL                // No arg for key function
);
```

**Authenticating the binding on the client side:** [Example code [here](TODO)]
```c++
RPC_STATUS status = RpcBindingSetAuthInfoEx(
    hExplicitBinding,		// the client's binding handle
    pszHostSPN,			// the server's service principale name (SPN)
    RPC_C_AUTHN_LEVEL_PKT,	// authentication level PKT
    RPC_C_AUTHN_WINNT,		// using NTLM as authentication service provider
    NULL,			// use current thread credentials
    RPC_C_AUTHZ_NAME,		// authorization based on the provided SPN
    &secQos			// Quality of Service structure
);
```

**Important to note**:<br>
**Setting an authenticated binding on the server side, does not enforce an authentication on the client side.**<br>
If for example no flags are set on the server side or only the *RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH* is set, unauthenticated clients can still connect to the RPC server.<br>
Setting the *RPC_IF_ALLOW_SECURE_ONLY* flag however prevents unauthenticated client bindings, because the client can't set an authentication level (which is what is checked with this flag) without creating an authenticated binding.  

### RPC Communication Flow

To wrap up all of the above, the communication flow can be summarized as follows:

1. **Server** registers Interface(s), e.g. using [RpcServerRegisterIf2](https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcserverregisterif2)
2. **Server** creates Binding Information using [RpcServerUseProtseq](https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcserveruseprotseq) & [RpcServerInqBindings](https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcserverinqbindings) 
3. **Server** registers Endpoints using [RpcEpRegister](https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcepregister) 
4. **Server** <u>can</u> registers Authentication Information using [RpcServerRegisterAuthInfo](https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcserverregisterauthinfo) (optional) 
5. **Server** listens for client connection(s) using [RpcServerListen](https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcserverlisten) 
6. **Client** creates a Binding Handle, using [RpcStringBindingCompose](https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcstringbindingcompose) & [RpcBindingFromStringBinding](https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingfromstringbinding) 
7. **Client** RPC runtime library finds the server process by querying the endpoint map on the server host system 
8. **Client** <u>can</u> authenticate binding handle using [RpcBindingSetAuthInfo](https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingsetauthinfo) (optional)
9. **Client** makes an RPC call by calling one of the functions defined in the used interface
10. **Client** RPC runtime library marshals the arguments in an [NDR](https://docs.microsoft.com/en-us/windows/win32/rpc/rpc-ndr-engine) format with the help of the NDR runtime and send them to the server, 
11. The **Server**'s RPC run time library gives the marshaled arguments to the stub, which unmarshals them, and then passes them to the server routines.
12. When the **Server** routines return, the stub picks up the \[out\] and \[in, out\] parameters (defined in the interface IDL file) and the return value, marshals them, and sends the marshaled data to the Server's RPC run time library, which transfers them back to the client. 

### Sample Implementation

As mentioned in the beginning the examples above are taken from my sample implementation, publicly available at [https://githuber.com/csandker/TODO](https://githuber.com/csandker/TODO).<br>
In this repo you will find the following sample implementations:
- Basic unauthenticated Server supporting unauthenticated Implicit Bindings
- Basic unauthenticated Client supporting unauthenticated Implicit Bindings
- Basic Server supporting unauthenticated Explicit Bindings
- Basic Server supporting authenticated Explicit Bindings
- Basic Client supporting authenticated Explicit Bindings without QOS
- Basic Client supporting authenticated Explicit Bindings with QOS

## Access Matrix

Alright if you understood all of the terminology above, here's the access matrix that visualizes which client can connect to which server.<br>
*Note: You can only connect an implicit clients to implicit servers, and explicit clients to explicit servers. Otherwise you get an Error 1717 (RPC_S_UNKNOWN_IF)*

![RPC Access Matrix](/public/img/2020-12-27-RPC/RPC_AccessMatrix.png)

## Attack Surface

Finally... after all that talk about RPC internals, let's talk about attack surface.<br>
Obviously there could be bugs and 0-days anywhere in the RPC communication chain, which always come down to a case-by-case analysis to understand exploit potentials, but there is also some exploitation potential of general RPC design concepts, which will I will highlight below.<br>
*Side note: If you are aware of interesting RPC CVEs, ping me at <span class="icon-span"><i class="fab fa-twitter">/</i>[0xcsandker](https://twitter.com/0xcsandker)</span>* 

### Finding RPC Servers

### Unauthorized Access
Once you identified an RPC server that exposes interesting functionality that could be useful to your attack chain the most obvious thing to check is if you can access the server unauthorized.<br>
You could either implement your own client, e.g. based on the my [Sample Implementation](#sample-implementation), or refer to the [Access Matrix](#access-matrix) to check if your client can connect to the server.

If you already got heads deep into reverse engineering the RPC server and found that the server sets authentication information by calling [RpcServerRegisterAuthInfo](https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcserverregisterauthinfo) with its SPN and a specified Service Provider, be reminded that **an authenticated server binding does not enforce the client to use an authenticated binding**. In other words: Just because the server sets authentication information does not mean the client needs to connect through an authenticated binding. Moreover when connecting to a server that sets authentication information be aware that **client calls with invalid credentials will not be dispatched by the run time library, however, client calls with no credentials will be dispatched**. Or to put it with Microsoft words:
<pre>
Remember that, by default, security is optional</pre>*Source: [https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcserverregisterifex](https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcserverregisterifex)*

### Client Impersonation

### Server Non-Impersonation 

### MITM Authenticated NTLM Connections

Relays (or cracking)

### MITM Authenticated GSS_NEGOTIATE Connections

Downgrading

## References

